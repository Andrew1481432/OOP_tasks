#include "Task312.h"

#include "class312/Class1.h"
#include "class312/Class2.h"

std::string Task312::getName()
{
	return "Занятие № 3_1_2";
}

int Task312::getId()
{
	return 312;
}

//Реализовать дружественную функцию,
//которая находит максимальное значение полей объекта первого типа и полей объекта второго типа.
int getMaxValue(Class1 *obj1, Class2 *obj2)
{
	int max = obj1->val;
	if (max < obj2->val1)
	{
		max = obj2->val1;
	}
	if (max < obj2->val2)
	{
		max = obj2->val2;
	}
	return max;
}

/*
Создать объект первого типа, у которого одно целочисленное свойство.
Значение данного свойства определяется посредством параметризированного конструктора.

Создать объект второго типа, у которого две целочисленных свойства. Значение данных свойств
определяется посредством метода объекта.
Реализовать дружественную функцию, которая находит максимальное значение полей объекта первого
типа и полей объекта второго типа.

Написать программу:
1. Вводит значение для поля объекта первого типа.
2. Создает объект первого типа.
3. Вводит значения полей для полей объекта второго типа.
4. Создает объект второго типа.
5. Определяет значения полей объекта второго типа.
6. Определяет максимальное значение полей, созданных двух объектов разного типа
посредством дружественной функции.
7. Выводит полученный результат.
 */
int Task312::execute()
{
	int n, n1 = 0;
	cin >> n;
	Class1 *obj1 = new Class1(n);
	Class2 *obj2 = new Class2();
	cin >> n >> n1;
	obj2->setValue(n, n1);
	int max = getMaxValue(obj1, obj2);
	cout << "max = " << max;
	delete obj1;
	delete obj2;
	return EXIT_SUCCESS;
}